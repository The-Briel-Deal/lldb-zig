//===- Z80LegalizerInfo.cpp --------------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the Machinelegalizer class for Z80.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "Z80LegalizerInfo.h"
#include "MCTargetDesc/Z80MCTargetDesc.h"
#include "Z80MachineFunctionInfo.h"
#include "Z80Subtarget.h"
#include "Z80TargetMachine.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/CodeGen/GlobalISel/LegalizerHelper.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include <functional>
#include <initializer_list>
using namespace llvm;
using namespace TargetOpcode;
using namespace LegalizeActions;
using namespace MIPatternMatch;

static LegalityPredicate typeNotInSet(unsigned TypeIdx,
                                      std::initializer_list<LLT> TypesInit) {
  using namespace LegalityPredicates;
  SmallVector<LLT, 8> Types = TypesInit;
  return [=](const LegalityQuery &Query) {
    return !is_contained(Types, Query.Types[TypeIdx]);
  };
}

static LegalityPredicate scalarNotInSet(unsigned TypeIdx,
                                        std::initializer_list<LLT> Types) {
  using namespace LegalityPredicates;
  return all(isScalar(TypeIdx), typeNotInSet(TypeIdx, Types));
}

static LegalizeRuleSet &
widenScalarToNextOrNarrowToLast(LegalizeRuleSet &Builder, unsigned TypeIdx,
                                std::initializer_list<LLT> TypesInit) {
  using namespace LegalityPredicates;
  SmallVector<LLT, 8> Types = TypesInit;
  assert(!Types.empty() && is_sorted(Types, [](LLT Ty1, LLT Ty2) {
    return Ty1.getSizeInBits() < Ty2.getSizeInBits();
  }) && "Expected type set to be not empty and sorted by width.");
  return Builder.maxScalar(TypeIdx, Types.back())
      .widenScalarIf(
          scalarNotInSet(TypeIdx, TypesInit), [=](const LegalityQuery &Query) {
            LLT QueryTy = Query.Types[TypeIdx];
            for (LLT Ty : reverse(Types))
              if (QueryTy.getSizeInBits() < Ty.getSizeInBits())
                return std::make_pair(TypeIdx, Ty);
            llvm_unreachable("Scalar wider than last already handled.");
          });
}

Z80LegalizerInfo::Z80LegalizerInfo(const Z80Subtarget &STI,
                                   const Z80TargetMachine &TM)
    : Subtarget(STI), TM(TM) {
  using namespace LegalizeActions;
  using namespace LegalityPredicates;
  using namespace LegalizeMutations;

  bool Is24Bit = Subtarget.is24Bit();
  LegalityPredicate pred24Bit = [=](const LegalityQuery &) { return Is24Bit; };

  std::array<LLT, 5> p;
  for (int AddrSpace = 0; AddrSpace != p.size(); ++AddrSpace)
    p[AddrSpace] = LLT::pointer(AddrSpace, TM.getPointerSizeInBits(AddrSpace));
  LLT s1 = LLT::scalar(1);
  LLT s8 = LLT::scalar(8);
  LLT s16 = LLT::scalar(16);
  LLT s24 = LLT::scalar(24);
  LLT s32 = LLT::scalar(32);
  LLT s48 = LLT::scalar(48);
  LLT s64 = LLT::scalar(64);
  LLT sMax = Is24Bit ? s24 : s16;
  LLT sOther = Is24Bit ? s16 : s24;

  auto LegalTypes24 = {p[0], p[1], p[2], p[3], p[4], s8, s16, s24};
  auto LegalTypes16 = {p[0], p[1], p[2], p[3], p[4], s8, s16};
  auto LegalTypes = Is24Bit ? LegalTypes24 : LegalTypes16;
  auto LegalTypesOther = Is24Bit ? LegalTypes16 : LegalTypes24;
  auto LegalTypesWithOne24 = {p[0], p[1], p[2], p[3], p[4], s1, s8, s16, s24};
  auto LegalTypesWithOne16 = {p[0], p[1], p[2], p[3], p[4], s1, s8, s16};
  auto LegalTypesWithOne = Is24Bit ? LegalTypesWithOne24 : LegalTypesWithOne16;
  auto LegalScalars24 = {s8, s16, s24};
  auto LegalScalars16 = {s8, s16};
  auto LegalScalars = Is24Bit ? LegalScalars24 : LegalScalars16;
  auto LegalLibcallScalars24 = {s8, s16, s24, s32, s64};
  auto LegalLibcallScalars16 = {s8, s16, s32, s64};
  auto LegalLibcallScalars =
      Is24Bit ? LegalLibcallScalars24 : LegalLibcallScalars16;
  auto LibcallScalars24 = {s8, s16, s24, s32, s48, s64};
  auto LibcallScalars16 = {s8, s16, s32, s64};
  auto LibcallScalars = Is24Bit ? LibcallScalars24 : LibcallScalars16;
  auto NotMax24 = {s8, s16}, NotMax16 = {s8};
  auto NotMax = Is24Bit ? NotMax24 : NotMax16;
  auto NotMin24 = {s16, s24}, NotMin16 = {s16};
  auto NotMin = Is24Bit ? NotMin24 : NotMin16;
  auto NotMaxWithOne24 = {s1, s8, s16}, NotMaxWithOne16 = {s1, s8};
  auto NotMaxWithOne = Is24Bit ? NotMaxWithOne24 : NotMaxWithOne16;

  const auto IsSpecificType = [](unsigned TypeIdx, LLT Ty) {
    return
        [=](const LegalityQuery &Query) { return Query.Types[TypeIdx] == Ty; };
  };

  const auto IsScalarPointer = [](unsigned ScalarTypeIdx,
                                  unsigned PointerTypeIdx, auto Predicate) {
    return [=](const LegalityQuery &Query) {
      return Query.Types[ScalarTypeIdx].isScalar() &&
             Query.Types[PointerTypeIdx].isPointer() &&
             Predicate(Query.Types[ScalarTypeIdx].getSizeInBits(),
                       Query.Types[PointerTypeIdx].getSizeInBits());
    };
  };

  const auto ChangeToSameSizeScalar = [](unsigned TypeIdx,
                                         unsigned SizeTypeIdx) {
    return [=](const LegalityQuery &Query) {
      return std::make_pair(
          TypeIdx, LLT::scalar(Query.Types[SizeTypeIdx].getSizeInBits()));
    };
  };

  getActionDefinitionsBuilder(G_IMPLICIT_DEF)
      .legalFor(LegalTypesWithOne);

  getActionDefinitionsBuilder(G_MERGE_VALUES)
      .legalForCartesianProduct(NotMin, NotMax)
      .clampScalar(0, *NotMin.begin(), *std::prev(NotMin.end()))
      .clampScalar(1, *NotMax.begin(), *std::prev(NotMax.end()));

  getActionDefinitionsBuilder(G_UNMERGE_VALUES)
      .legalForCartesianProduct(NotMax, NotMin)
      .clampScalar(1, *NotMin.begin(), *std::prev(NotMin.end()))
      .clampScalar(0, *NotMax.begin(), *std::prev(NotMax.end()));

  getActionDefinitionsBuilder({G_EXTRACT, G_INSERT})
      .customForCartesianProduct(LegalTypes, LegalTypes)
      .unsupported();

  getActionDefinitionsBuilder({G_ZEXT, G_ANYEXT})
      .legalForCartesianProduct(LegalScalars, NotMaxWithOne)
      .clampScalar(0, *LegalScalars.begin(), *std::prev(LegalScalars.end()))
      .clampScalar(1, *NotMaxWithOne.begin(), *std::prev(NotMaxWithOne.end()));

  getActionDefinitionsBuilder(G_SEXT)
      .legalForCartesianProduct(LegalScalars, {s1})
      .maxScalar(0, sMax)
      .maxScalar(0, s8)
      .maxScalar(1, s8);

  getActionDefinitionsBuilder(G_TRUNC)
      .legalForCartesianProduct(NotMaxWithOne, LegalScalars)
      .clampScalar(1, *LegalScalars.begin(), *std::prev(LegalScalars.end()))
      .clampScalar(0, *NotMaxWithOne.begin(), *std::prev(NotMaxWithOne.end()));

  getActionDefinitionsBuilder({G_FREEZE, G_PHI, G_CONSTANT})
      .legalFor(LegalTypes)
      .clampScalar(0, s8, sMax);

  getActionDefinitionsBuilder(G_FCONSTANT)
      .customFor({s32, s64});

  getActionDefinitionsBuilder(G_PTRTOINT)
      .legalIf(IsScalarPointer(0, 1, std::equal_to<>{}))
      .widenScalarIf(IsScalarPointer(0, 1, std::less<>{}),
                     ChangeToSameSizeScalar(0, 1))
      .narrowScalarIf(IsScalarPointer(0, 1, std::greater<>{}),
                      ChangeToSameSizeScalar(0, 1));

  getActionDefinitionsBuilder({G_INTTOPTR, G_PTR_ADD})
      .legalIf(IsScalarPointer(1, 0, std::equal_to<>{}))
      .widenScalarIf(IsScalarPointer(1, 0, std::less<>{}),
                     ChangeToSameSizeScalar(1, 0))
      .narrowScalarIf(IsScalarPointer(1, 0, std::greater<>{}),
                      ChangeToSameSizeScalar(1, 0));

  getActionDefinitionsBuilder(G_PTRMASK)
      .legalFor({p[2], s8})
      .customIf(IsScalarPointer(1, 0, std::equal_to<>{}))
      .widenScalarIf(IsScalarPointer(1, 0, std::less<>{}),
                     ChangeToSameSizeScalar(1, 0))
      .narrowScalarIf(IsScalarPointer(1, 0, std::greater<>{}),
                      ChangeToSameSizeScalar(1, 0));

  getActionDefinitionsBuilder({G_ADD, G_SUB})
      .legalFor({s8})
      .customFor(LegalLibcallScalars)
      .clampScalar(0, s8, sMax);

  getActionDefinitionsBuilder({G_UADDO, G_UADDE, G_USUBO, G_USUBE,
                               G_SADDO, G_SADDE, G_SSUBO, G_SSUBE})
      .legalForCartesianProduct(LegalScalars, {s1})
      .clampScalar(0, s8, sMax);

  getActionDefinitionsBuilder(G_MUL)
      .legalIf(all(pred24Bit, typeIs(0, s8)))
      .libcallFor(LegalLibcallScalars)
      .narrowScalarIf(all(pred24Bit, typeIs(0, s48)), changeTo(0, s24))
      .clampScalar(0, s8, s32);

  getActionDefinitionsBuilder({G_SDIV, G_UDIV, G_SREM, G_UREM})
      .libcallFor(LegalLibcallScalars)
      .clampScalar(0, s8, s32);

  getActionDefinitionsBuilder({G_AND, G_OR, G_XOR})
      .legalFor({s8})
      .customFor(LegalLibcallScalars)
      .clampScalar(0, s8, s32);

  widenScalarToNextOrNarrowToLast(
      getActionDefinitionsBuilder({G_SHL, G_LSHR, G_ASHR})
          .customForCartesianProduct(LegalLibcallScalars, {s8})
          .clampScalar(1, s8, s8)
          .narrowScalarIf(all(pred24Bit, typeIs(0, s48)), changeTo(0, s24)),
      0, LibcallScalars);

  getActionDefinitionsBuilder({G_FSHL, G_FSHR, G_ROTR, G_ROTL, G_UMULO,
                               G_UMULFIX, G_SMULFIX, G_SMULFIXSAT, G_UMULFIXSAT,
                               G_UDIVFIX, G_SDIVFIX, G_SDIVFIXSAT, G_UDIVFIXSAT,
                               G_FCANONICALIZE, G_MEMCPY, G_MEMCPY_INLINE,
                               G_MEMMOVE, G_MEMSET, G_BZERO})
      .custom();

  getActionDefinitionsBuilder({G_INTRINSIC_TRUNC,
                               G_INTRINSIC_ROUND,
                               G_INTRINSIC_ROUNDEVEN,
                               G_FADD,
                               G_FSUB,
                               G_FMUL,
                               G_FMA,
                               G_FMAD,
                               G_FDIV,
                               G_FREM,
                               G_FPOW,
                               G_FEXP,
                               G_FEXP2,
                               G_FLOG,
                               G_FLOG2,
                               G_FLOG10,
                               G_FNEG,
                               G_FABS,
                               G_FMINNUM,
                               G_FMAXNUM,
                               G_FCEIL,
                               G_FCOS,
                               G_FSIN,
                               G_FSQRT,
                               G_FFLOOR,
                               G_FRINT,
                               G_FNEARBYINT})
      .libcallFor({s32, s64});

  getActionDefinitionsBuilder({G_INTRINSIC_LRINT, G_LROUND})
      .libcallForCartesianProduct({s32}, {s32, s64});

  getActionDefinitionsBuilder({G_INTRINSIC_LLRINT, G_LLROUND})
      .libcallForCartesianProduct({s64}, {s32, s64});

  getActionDefinitionsBuilder(G_FPEXT).libcallFor({{s64, s32}});

  getActionDefinitionsBuilder(G_FPTRUNC).libcallFor({{s32, s64}});

  getActionDefinitionsBuilder({G_FPTOSI, G_FPTOUI})
      .libcallForCartesianProduct({s32, s64}, {s32, s64})
      .clampScalar(0, s32, s64);

  getActionDefinitionsBuilder({G_SITOFP, G_UITOFP})
      .libcallForCartesianProduct({s32, s64}, {s32, s64})
      .clampScalar(1, s32, s64);

  getActionDefinitionsBuilder(G_FCOPYSIGN).libcallFor({{s32, s32}, {s64, s64}});

  getActionDefinitionsBuilder({G_LOAD, G_STORE})
      .legalForCartesianProduct(LegalTypes, {p[0]})
      .legalForCartesianProduct(LegalTypesOther, {p[1]})
      .legalForCartesianProduct({s8}, {p[2], p[3], p[4]})
      .minScalar(0, s8)
      .maxScalarIf(IsSpecificType(1, p[0]), 0, sMax)
      .maxScalarIf(IsSpecificType(1, p[1]), 0, sOther)
      .maxScalar(0, s8);
  for (unsigned MemOp : {G_LOAD, G_STORE})
    getLegacyLegalizerInfo().setLegalizeScalarToDifferentSizeStrategy(
        MemOp, 0, LegacyLegalizerInfo::narrowToSmallerAndWidenToSmallest);

  getActionDefinitionsBuilder(
      {G_FRAME_INDEX, G_GLOBAL_VALUE, G_BRINDIRECT, G_JUMP_TABLE})
      .legalFor({p[0]});

  getActionDefinitionsBuilder(G_VASTART).customFor({p[0]});

  getActionDefinitionsBuilder(G_ICMP)
      .legalForCartesianProduct({s1}, LegalTypes)
      .customForCartesianProduct({s1}, {s32, s64})
      .clampScalar(1, s8, s64);

  getActionDefinitionsBuilder(G_FCMP).customForCartesianProduct({s1},
                                                                {s32, s64});

  getActionDefinitionsBuilder(G_BRCOND).legalFor({s1});

  getActionDefinitionsBuilder(G_BRJT)
      .legalForCartesianProduct({p[0]}, LegalScalars)
      .clampScalar(1, s8, sMax);

  getActionDefinitionsBuilder(G_SELECT)
      .legalForCartesianProduct(LegalTypes, {s1})
      .clampScalar(0, s8, sMax);

  getActionDefinitionsBuilder(
      {G_SDIVREM, G_UDIVREM, G_ABS, G_DYN_STACKALLOC, G_SEXT_INREG, G_SMULO,
       G_SMULH, G_UMULH, G_SMIN, G_SMAX, G_UMIN, G_UMAX, G_UADDSAT, G_SADDSAT,
       G_USUBSAT, G_SSUBSAT, G_USHLSAT, G_SSHLSAT, G_FPOWI})
      .lower();

  getActionDefinitionsBuilder({G_CTTZ, G_CTTZ_ZERO_UNDEF, G_CTLZ_ZERO_UNDEF})
      .lowerForCartesianProduct({s8}, LegalLibcallScalars)
      .clampScalar(0, s8, s8);

  getActionDefinitionsBuilder(G_CTLZ)
      .customForCartesianProduct({s8}, LegalLibcallScalars)
      .clampScalar(0, s8, s8);

  getActionDefinitionsBuilder(G_CTPOP)
      .libcallForCartesianProduct({s8}, LegalLibcallScalars)
      .clampScalar(0, s8, s8);

  getActionDefinitionsBuilder(G_BSWAP)
      .legalFor({s16})
      .libcallFor({s32, s64})
      .clampScalar(0, s16, s64);

  getActionDefinitionsBuilder(G_BITREVERSE)
      .libcallFor(LegalLibcallScalars)
      .clampScalar(0, s8, s64);

  getLegacyLegalizerInfo().computeTables();
  verify(*STI.getInstrInfo());
}

LegalizerHelper::LegalizeResult Z80LegalizerInfo::legalizeCustomMaybeLegal(
    LegalizerHelper &Helper, MachineInstr &MI,
    LostDebugLocObserver &LocObserver) const {
  Helper.MIRBuilder.setInstrAndDebugLoc(MI);
  switch (MI.getOpcode()) {
  default:
    // No idea what to do.
    return LegalizerHelper::UnableToLegalize;
  case G_ADD:
  case G_SUB:
    return legalizeAddSub(Helper, MI, LocObserver);
  case G_AND:
  case G_OR:
  case G_XOR:
  case G_PTRMASK:
    return legalizeBitwise(Helper, MI, LocObserver);
  case G_EXTRACT:
  case G_INSERT:
    return legalizeExtractInsert(Helper, MI);
  case G_FCONSTANT:
    return legalizeFConstant(Helper, MI);
  case G_VASTART:
    return legalizeVAStart(Helper, MI);
  case G_SHL:
  case G_LSHR:
  case G_ASHR:
    return legalizeShift(Helper, MI, LocObserver);
  case G_FSHL:
  case G_FSHR:
  case G_ROTR:
  case G_ROTL:
    return legalizeFunnelShift(Helper, MI);
  case G_ICMP:
  case G_FCMP:
    return legalizeCompare(Helper, MI);
  case G_UMULO:
    return legalizeMultiplyWithOverflow(Helper, MI);
  case G_SMULFIX:
  case G_UMULFIX:
  case G_SMULFIXSAT:
  case G_UMULFIXSAT:
    return legalizeFixedMultiply(Helper, MI);
  case G_SDIVFIX:
  case G_UDIVFIX:
  case G_SDIVFIXSAT:
  case G_UDIVFIXSAT:
    return legalizeFixedDivide(Helper, MI);
  case G_FCANONICALIZE:
    return legalizeFCanonicalize(Helper, MI);
  case G_CTLZ:
    return legalizeCtlz(Helper, MI);
  case G_MEMCPY:
  case G_MEMCPY_INLINE:
  case G_MEMMOVE:
  case G_MEMSET:
  case G_BZERO:
    return legalizeMemIntrinsic(Helper, MI, LocObserver);
  }
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeAddSub(LegalizerHelper &Helper, MachineInstr &MI,
                                 LostDebugLocObserver &LocObserver) const {
  assert((MI.getOpcode() == G_ADD || MI.getOpcode() == G_SUB) &&
         "Unexpected opcode");
  Function &F = Helper.MIRBuilder.getMF().getFunction();
  MachineRegisterInfo &MRI = *Helper.MIRBuilder.getMRI();
  Register DstReg = MI.getOperand(0).getReg();
  LLT LLTy = MRI.getType(DstReg);
  unsigned Size = LLTy.getSizeInBits();
  bool LegalSize = Size == 16 || (Subtarget.is24Bit() && Size == 24);
  Register LHSReg;
  if (mi_match(MI, MRI, m_Neg(m_Reg(LHSReg)))) {
    if (!F.hasOptSize() && LegalSize)
      return LegalizerHelper::Legalized;
    auto &Ctx = F.getContext();
    RTLIB::Libcall Libcall;
    switch (Size) {
    case 16:
      Libcall = RTLIB::NEG_I16;
      break;
    case 24:
      Libcall = RTLIB::NEG_I24;
      break;
    case 32:
      Libcall = RTLIB::NEG_I32;
      break;
    case 64:
      Libcall = RTLIB::NEG_I64;
      break;
    default:
      llvm_unreachable("Unexpected type");
    }
    Type *Ty = IntegerType::get(Ctx, Size);
    auto Result = createLibcall(Helper.MIRBuilder, Libcall, {DstReg, Ty, 0},
                                {{LHSReg, Ty, 0}});
    MI.eraseFromParent();
    return Result;
  }
  if (LegalSize)
    return LegalizerHelper::Legalized;
  return Helper.libcall(MI, LocObserver);
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeBitwise(LegalizerHelper &Helper, MachineInstr &MI,
                                  LostDebugLocObserver &LocObserver) const {
  assert((MI.getOpcode() == G_AND || MI.getOpcode() == G_OR ||
          MI.getOpcode() == G_XOR || MI.getOpcode() == G_PTRMASK) &&
         "Unexpected opcode");
  Function &F = Helper.MIRBuilder.getMF().getFunction();
  bool OptSize = F.hasOptSize();
  MachineRegisterInfo &MRI = *Helper.MIRBuilder.getMRI();
  Register DstReg = MI.getOperand(0).getReg();
  unsigned Size = MRI.getType(DstReg).getSizeInBits();
  if (!OptSize && Size == 16)
    if (Helper.narrowScalar(MI, 0, LLT::scalar(8)) ==
        LegalizerHelper::Legalized)
      return LegalizerHelper::Legalized;
  Register LHSReg;
  if (mi_match(MI, MRI, m_Not(m_Reg(LHSReg)))) {
    if (!OptSize && (Size == 16 || (Subtarget.is24Bit() && Size == 24))) {
      Helper.MIRBuilder.buildSub(
          DstReg, Helper.MIRBuilder.buildConstant(LLT::scalar(Size), -1),
          MI.getOperand(1).getReg());
      MI.eraseFromParent();
      return LegalizerHelper::Legalized;
    }
    auto &Ctx = F.getContext();
    RTLIB::Libcall Libcall;
    switch (Size) {
    default: llvm_unreachable("Unexpected type");
    case 16: Libcall = RTLIB::NOT_I16; break;
    case 24: Libcall = RTLIB::NOT_I24; break;
    case 32: Libcall = RTLIB::NOT_I32; break;
    case 64: Libcall = RTLIB::NOT_I64; break;
    }
    Type *Ty = IntegerType::get(Ctx, Size);
    auto Result = createLibcall(Helper.MIRBuilder, Libcall, {DstReg, Ty, 0},
                                {{LHSReg, Ty, 0}});
    MI.eraseFromParent();
    return Result;
  }
  if (MI.getOpcode() == G_PTRMASK) {
    auto &Ctx = F.getContext();
    RTLIB::Libcall Libcall;
    switch (Size) {
    default: llvm_unreachable("Unexpected type");
    case 16: Libcall = RTLIB::AND_I16; break;
    case 24: Libcall = RTLIB::AND_I24; break;
    case 32: Libcall = RTLIB::AND_I32; break;
    case 64: Libcall = RTLIB::AND_I64; break;
    }
    Type *Ty = IntegerType::get(Ctx, Size);
    auto Result = createLibcall(Helper.MIRBuilder, Libcall, {DstReg, Ty, 0},
                                {{MI.getOperand(1).getReg(), Ty, 0},
                                 {MI.getOperand(2).getReg(), Ty, 1}});
    MI.eraseFromParent();
    return Result;
  }
  return Helper.libcall(MI, LocObserver);
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeExtractInsert(LegalizerHelper &Helper,
                                        MachineInstr &MI) const {
  assert((MI.getOpcode() == G_EXTRACT || MI.getOpcode() == G_INSERT) &&
         "Unexpected opcode");
  return MI.getOperand(MI.getNumExplicitOperands() - 1).getImm() & 7
             ? LegalizerHelper::UnableToLegalize
             : LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeFConstant(LegalizerHelper &Helper,
                                    MachineInstr &MI) const {
  assert(MI.getOpcode() == G_FCONSTANT && "Unexpected opcode");
  Helper.Observer.changingInstr(MI);
  MI.setDesc(Helper.MIRBuilder.getTII().get(G_CONSTANT));
  MachineOperand &Imm = MI.getOperand(1);
  const ConstantFP *FPImm = Imm.getFPImm();
  Imm.ChangeToCImmediate(ConstantInt::get(
      FPImm->getContext(), FPImm->getValueAPF().bitcastToAPInt()));
  Helper.Observer.changedInstr(MI);
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeVAStart(LegalizerHelper &Helper,
                                  MachineInstr &MI) const {
  assert(MI.getOpcode() == G_VASTART && "Unexpected opcode");
  MachineFunction &MF = Helper.MIRBuilder.getMF();
  Z80MachineFunctionInfo &FuncInfo = *MF.getInfo<Z80MachineFunctionInfo>();
  int FrameIdx = FuncInfo.getVarArgsFrameIndex();
  assert(FrameIdx && "Found va_start but never setVarArgsFrameIndex!");
  LLT p0 = LLT::pointer(0, TM.getPointerSizeInBits(0));
  Helper.MIRBuilder.buildStore(Helper.MIRBuilder.buildFrameIndex(p0, FrameIdx),
                               MI.getOperand(0).getReg(),
                               *MI.memoperands().front());
  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeShift(LegalizerHelper &Helper, MachineInstr &MI,
                                LostDebugLocObserver &LocObserver) const {
  unsigned Opc = MI.getOpcode();
  assert((Opc == G_SHL || Opc == G_LSHR || Opc == G_ASHR) &&
         "Unexpected opcode");
  MachineRegisterInfo &MRI = *Helper.MIRBuilder.getMRI();
  Register DstReg = MI.getOperand(0).getReg();
  LLT Ty = MRI.getType(DstReg);
  if (auto Amt =
          getIConstantVRegValWithLookThrough(MI.getOperand(2).getReg(), MRI)) {
    if (Ty == LLT::scalar(8) && Amt->Value == 1)
      return LegalizerHelper::AlreadyLegal;
    if ((Opc == G_SHL || Opc == G_LSHR) && Ty == LLT::scalar(16) &&
        Amt->Value == 8)
      return LegalizerHelper::AlreadyLegal;
    if (MI.getOpcode() == G_ASHR && Amt->Value == Ty.getSizeInBits() - 1 &&
        (Ty == LLT::scalar(8) || Ty == LLT::scalar(16) ||
         (Subtarget.is24Bit() && Ty == LLT::scalar(24))))
      return LegalizerHelper::AlreadyLegal;
  }
  return Helper.libcall(MI, LocObserver);
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeFunnelShift(LegalizerHelper &Helper,
                                      MachineInstr &MI) const {
  unsigned Opc = MI.getOpcode();
  assert((Opc == G_FSHL || Opc == G_FSHR || Opc == G_ROTR || Opc == G_ROTL) &&
         "Unexpected opcode");

  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();

  Register DstReg = MI.getOperand(0).getReg();
  Register FwdReg = MI.getOperand(1).getReg();
  Register RevReg = MI.getOperand(MI.getNumExplicitOperands() - 2).getReg();
  Register AmtReg = MI.getOperand(MI.getNumExplicitOperands() - 1).getReg();

  LLT Ty = MRI.getType(DstReg);
  if (Ty == LLT::scalar(8))
    if (auto Amt = getIConstantVRegValWithLookThrough(AmtReg, MRI))
      return LegalizerHelper::AlreadyLegal;

  unsigned FwdShiftOpc = G_SHL;
  unsigned RevShiftOpc = G_LSHR;
  if (Opc == G_FSHR || Opc == G_ROTR) {
    std::swap(FwdReg, RevReg);
    std::swap(FwdShiftOpc, RevShiftOpc);
  }

  auto MaskI = MIRBuilder.buildConstant(Ty, Ty.getSizeInBits() - 1);
  auto FwdAmtI = MIRBuilder.buildAnd(Ty, AmtReg, MaskI);
  auto FwdI = MIRBuilder.buildInstr(FwdShiftOpc, {Ty}, {FwdReg, FwdAmtI});
  auto RevAmtI = MIRBuilder.buildAnd(
      Ty, MIRBuilder.buildSub(Ty, MIRBuilder.buildConstant(Ty, 0), AmtReg),
      MaskI);
  auto RevI = MIRBuilder.buildInstr(RevShiftOpc, {Ty}, {RevReg, RevAmtI});
  MIRBuilder.buildOr(DstReg, FwdI, RevI);
  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeCompare(LegalizerHelper &Helper,
                                  MachineInstr &MI) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();
  Register DstReg = MI.getOperand(0).getReg();
  auto Pred = CmpInst::Predicate(MI.getOperand(1).getPredicate());
  Register LHSReg = MI.getOperand(2).getReg();
  Register RHSReg = MI.getOperand(3).getReg();
  LLT OpTy = MRI.getType(LHSReg);
  unsigned OpSize = OpTy.getSizeInBits();
  assert(MRI.getType(DstReg) == LLT::scalar(1) && !OpTy.isVector() &&
         MRI.getType(RHSReg) == OpTy && "Unexpected type");

  Type *Ty;
  RTLIB::Libcall Libcall;
  bool IsSigned, IsSwapped, IsConst;
  Z80::CondCode CC =
      Z80::GetBranchConditionForPredicate(Pred, IsSigned, IsSwapped, IsConst);
  if (IsSwapped)
    std::swap(LHSReg, RHSReg);
  auto &Ctx = MIRBuilder.getMF().getFunction().getContext();
  bool ZeroRHS = false;
  if (MI.getOpcode() == G_ICMP) {
    Ty = IntegerType::get(Ctx, OpSize);
    if (auto C = getIConstantVRegVal(RHSReg, MRI))
      ZeroRHS = *C == 0;
    switch (OpSize) {
    case 32:
      Libcall = ZeroRHS    ? RTLIB::CMP_I32_0
                : IsSigned ? RTLIB::SCMP_I32
                           : RTLIB::CMP_I32;
      break;
    case 64:
      Libcall = ZeroRHS    ? RTLIB::CMP_I64_0
                : IsSigned ? RTLIB::SCMP_I64
                           : RTLIB::CMP_I64;
      break;
    default:
      llvm_unreachable("Unexpected type");
    }
  } else {
    assert(MI.getOpcode() == G_FCMP && "Unexpected opcode");
    assert(OpTy.isScalar() && "Unexpected type");
    switch (OpSize) {
    case 32:
      Ty = Type::getFloatTy(Ctx);
      Libcall = RTLIB::CMP_F32;
      break;
    case 64:
      Ty = Type::getDoubleTy(Ctx);
      Libcall = RTLIB::CMP_F64;
      break;
    default:
      llvm_unreachable("Unexpected type");
    }
  }
  if (!IsConst) {
    LLT s8 = LLT::scalar(8);
    Type *Int8Ty = Type::getInt8Ty(Ctx);
    Register FlagsReg = MRI.createGenericVirtualRegister(s8);
    CallLowering::ArgInfo FlagsArg(FlagsReg, Int8Ty,
                                   CallLowering::ArgInfo::NoArgIndex);
    CallLowering::ArgInfo Args[2] = {{LHSReg, Ty, 0}, {RHSReg, Ty, 1}};
    auto Result = createLibcall(MIRBuilder, Libcall, FlagsArg,
                                makeArrayRef(Args, 2 - ZeroRHS));
    if (Result != LegalizerHelper::Legalized)
      return Result;
    MIRBuilder.buildCopy(Register(Z80::F), FlagsReg);
    if (IsSigned && !ZeroRHS)
      Subtarget.getCallLowering()->buildSCMP(MIRBuilder);
  } else
    MIRBuilder.buildInstr(Z80::RCF);
  MIRBuilder.buildInstr(Z80::SetCC, {DstReg}, {int64_t(CC)});
  MRI.setRegClass(DstReg, &Z80::R8RegClass);
  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeFixedMultiply(LegalizerHelper &Helper,
                                        MachineInstr &MI) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();

  unsigned Opc = MI.getOpcode();
  bool Signed = Opc == G_SMULFIX || Opc == G_SMULFIXSAT;
  bool Sat = Opc == G_SMULFIXSAT || Opc == G_UMULFIXSAT;
  assert((Signed || Sat || Opc == G_UMULFIX) && "Unexpected opcode");

  Register DstReg = MI.getOperand(0).getReg();
  unsigned OpSize = MRI.getType(DstReg).getSizeInBits();
  Register LHSReg = MI.getOperand(1).getReg();
  Register RHSReg = MI.getOperand(2).getReg();
  uint64_t Shift = MI.getOperand(3).getImm();
  unsigned WideSize = OpSize * 2;
  LLT WideTy = LLT::scalar(WideSize);

  if (Shift >= WideSize)
    return LegalizerHelper::UnableToLegalize;

  Register WideDstReg =
      MIRBuilder
          .buildInstr(Signed ? G_ASHR : G_LSHR, {WideTy},
                      {MIRBuilder.buildMul(
                           WideTy,
                           MIRBuilder.buildInstr(Signed ? G_SEXT : G_ZEXT,
                                                 {WideTy}, {LHSReg}),
                           MIRBuilder.buildInstr(Signed ? G_SEXT : G_ZEXT,
                                                 {WideTy}, {RHSReg})),
                       MIRBuilder.buildConstant(WideTy, Shift)})
          .getReg(0);
  if (Sat) {
    unsigned MinOpc;
    APInt Max;
    if (Signed) {
      WideDstReg =
          MIRBuilder
              .buildSMax(
                  WideTy, WideDstReg,
                  MIRBuilder.buildConstant(
                      WideTy, APInt::getSignedMinValue(OpSize).sext(WideSize)))
              .getReg(0);
      MinOpc = G_SMIN;
      Max = APInt::getSignedMaxValue(OpSize).sext(WideSize);
    } else {
      MinOpc = G_UMIN;
      Max = APInt::getMaxValue(OpSize).zext(WideSize);
    }
    WideDstReg =
        MIRBuilder
            .buildInstr(MinOpc, {WideTy},
                        {WideDstReg, MIRBuilder.buildConstant(WideTy, Max)})
            .getReg(0);
  }
  MIRBuilder.buildTrunc(DstReg, WideDstReg);

  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeFixedDivide(LegalizerHelper &Helper,
                                      MachineInstr &MI) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();

  unsigned Opc = MI.getOpcode();
  bool Signed = Opc == G_SDIVFIX || Opc == G_SDIVFIXSAT;
  bool Sat = Opc == G_SDIVFIXSAT || Opc == G_UDIVFIXSAT;
  assert((Signed || Sat || Opc == G_UDIVFIX) && "Unexpected opcode");

  Register DstReg = MI.getOperand(0).getReg();
  LLT OpTy = MRI.getType(DstReg);
  unsigned OpSize = OpTy.getSizeInBits();
  Register LHSReg = MI.getOperand(1).getReg();
  Register RHSReg = MI.getOperand(2).getReg();
  uint64_t Shift = MI.getOperand(3).getImm();
  unsigned WideSize = OpSize * 2;
  LLT WideTy = LLT::scalar(WideSize);

  if (Shift > 0 && Shift <= OpSize / 2 && WideSize > 64) {
    // FIXME: accuracy
    auto DivRemI = MIRBuilder.buildInstr(Signed ? G_SDIVREM : G_UDIVREM,
                                         {OpTy, OpTy}, {LHSReg, RHSReg});
    Register PosReg = DivRemI.getReg(1);
    if (Signed)
      PosReg = MIRBuilder
                   .buildXor(OpTy, PosReg,
                             MIRBuilder.buildAShr(
                                 OpTy, PosReg,
                                 MIRBuilder.buildConstant(OpTy, OpSize - 1)))
                   .getReg(0);
    Register ScaleReg =
        MIRBuilder
            .buildSelect(
                OpTy,
                MIRBuilder.buildICmp(
                    CmpInst::ICMP_ULT, LLT::scalar(1), PosReg,
                    MIRBuilder.buildConstant(
                        OpTy, APInt::getOneBitSet(OpSize, Shift - Signed))),
                MIRBuilder.buildConstant(OpTy, Shift - Signed),
                MIRBuilder.buildAdd(
                    OpTy,
                    MIRBuilder.buildInstr(G_CTLZ_ZERO_UNDEF, {OpTy}, {PosReg}),
                    MIRBuilder.buildConstant(OpTy, -Signed)))
            .getReg(0);
    Register ShiftReg = MIRBuilder.buildConstant(OpTy, Shift).getReg(0);
    Register InvScaleReg =
        MIRBuilder.buildSub(OpTy, ShiftReg, ScaleReg).getReg(0);
    Register OneReg = MIRBuilder.buildConstant(OpTy, 1).getReg(0);
    MIRBuilder.buildAdd(
        DstReg, MIRBuilder.buildShl(OpTy, DivRemI.getReg(0), ShiftReg),
        MIRBuilder.buildInstr(
            Signed ? G_ASHR : G_LSHR, {OpTy},
            {MIRBuilder.buildInstr(
                 Signed ? G_SDIV : G_UDIV, {OpTy},
                 {MIRBuilder.buildShl(OpTy, DivRemI.getReg(1), ScaleReg),
                  MIRBuilder.buildAdd(
                      OpTy, RHSReg,
                      MIRBuilder.buildLShr(
                          OpTy, MIRBuilder.buildShl(OpTy, OneReg, InvScaleReg),
                          OneReg))}),
             InvScaleReg}));
    MI.eraseFromParent();
    return LegalizerHelper::Legalized;
  }

  if (Shift >= WideSize)
    return LegalizerHelper::UnableToLegalize;

  Register WideDstReg =
      MIRBuilder
          .buildInstr(Signed ? G_SDIV : G_UDIV, {WideTy},
                      {MIRBuilder.buildShl(
                           WideTy,
                           MIRBuilder.buildInstr(Signed ? G_SEXT : G_ZEXT,
                                                 {WideTy}, {LHSReg}),
                           MIRBuilder.buildConstant(WideTy, Shift)),
                       MIRBuilder.buildInstr(Signed ? G_SEXT : G_ZEXT, {WideTy},
                                             {RHSReg})})
          .getReg(0);
  if (Sat) {
    unsigned MinOpc;
    APInt Max;
    if (Signed) {
      WideDstReg =
          MIRBuilder
              .buildSMax(
                  WideTy, WideDstReg,
                  MIRBuilder.buildConstant(
                      WideTy, APInt::getSignedMinValue(OpSize).sext(WideSize)))
              .getReg(0);
      MinOpc = G_SMIN;
      Max = APInt::getSignedMaxValue(OpSize).sext(WideSize);
    } else {
      MinOpc = G_UMIN;
      Max = APInt::getMaxValue(OpSize).zext(WideSize);
    }
    WideDstReg =
        MIRBuilder
            .buildInstr(MinOpc, {WideTy},
                        {WideDstReg, MIRBuilder.buildConstant(WideTy, Max)})
            .getReg(0);
  }
  MIRBuilder.buildTrunc(DstReg, WideDstReg);

  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeMultiplyWithOverflow(LegalizerHelper &Helper,
                                               MachineInstr &MI) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();

  assert(MI.getOpcode() == G_UMULO && "Unexpected opcode");

  Register MulReg = MI.getOperand(0).getReg();
  Register OverflowReg = MI.getOperand(1).getReg();
  LLT Ty = MRI.getType(MulReg);

  Register LHSReg = MI.getOperand(2).getReg();
  Register RHSReg = MI.getOperand(3).getReg();

  MIRBuilder.buildMul(MulReg, LHSReg, RHSReg);

  auto One = MIRBuilder.buildConstant(Ty, 1);
  auto Max =
      MIRBuilder.buildConstant(Ty, APInt::getMaxValue(Ty.getSizeInBits()));
  MIRBuilder.buildICmp(
      CmpInst::ICMP_UGT, OverflowReg, LHSReg,
      MIRBuilder.buildInstr(G_UDIV, {Ty},
                            {Max, MIRBuilder.buildUMax(Ty, RHSReg, One)}));

  MI.eraseFromParent();
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeFCanonicalize(LegalizerHelper &Helper,
                                        MachineInstr &MI) const {
  Helper.Observer.changingInstr(MI);
  MI.setDesc(Helper.MIRBuilder.getTII().get(COPY));
  Helper.Observer.changedInstr(MI);
  return LegalizerHelper::Legalized;
}

LegalizerHelper::LegalizeResult
Z80LegalizerInfo::legalizeCtlz(LegalizerHelper &Helper,
                               MachineInstr &MI) const {
  assert(MI.getOpcode() == G_CTLZ);
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();
  auto &Ctx = MIRBuilder.getMF().getFunction().getContext();

  Register DstReg = MI.getOperand(0).getReg();
  LLT DstTy = MRI.getType(DstReg);
  unsigned DstSize = DstTy.getSizeInBits();
  Register SrcReg = MI.getOperand(1).getReg();
  LLT SrcTy = MRI.getType(SrcReg);
  unsigned SrcSize = SrcTy.getSizeInBits();

  if (DstTy != LLT::scalar(8) || !SrcTy.isScalar())
    return LegalizerHelper::UnableToLegalize;

  RTLIB::Libcall Libcall;
  switch (SrcSize) {
  default: return LegalizerHelper::UnableToLegalize;
  case  8: Libcall = RTLIB::CTLZ_I8 ; break;
  case 16: Libcall = RTLIB::CTLZ_I16; break;
  case 24: Libcall = RTLIB::CTLZ_I24; break;
  case 32: Libcall = RTLIB::CTLZ_I32; break;
  case 64: Libcall = RTLIB::CTLZ_I64; break;
  }
  auto Result = createLibcall(MIRBuilder, Libcall,
                              {DstReg, IntegerType::get(Ctx, DstSize), 0},
                              {{SrcReg, IntegerType::get(Ctx, SrcSize), 0}});
  MI.eraseFromParent();
  return Result;
}

LegalizerHelper::LegalizeResult Z80LegalizerInfo::legalizeMemIntrinsic(
    LegalizerHelper &Helper, MachineInstr &MI,
    LostDebugLocObserver &LocObserver) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineRegisterInfo &MRI = *MIRBuilder.getMRI();
  MachineFunction &MF = MIRBuilder.getMF();
  const DataLayout &DL = MF.getDataLayout();
  bool Is24Bit = Subtarget.is24Bit();

  unsigned Opc = MI.getOpcode();
  assert((Opc == G_MEMCPY || Opc == G_MEMCPY_INLINE || Opc == G_MEMMOVE ||
          Opc == G_MEMSET || Opc == G_BZERO) &&
         "Unexpected opcode");

  auto MOI = MI.operands_begin();

  Register DstReg = MOI->getReg();
  LLT DstTy = MRI.getType(DstReg);

  Register SrcReg = Opc != G_BZERO
                        ? (++MOI)->getReg()
                        : MIRBuilder.buildConstant(LLT::scalar(8), 0).getReg(0);
  LLT SrcTy = MRI.getType(SrcReg);

  Register LenReg = (++MOI)->getReg();
  LLT LenTy = LLT::scalar(DL.getIndexSizeInBits(DstTy.getAddressSpace()));
  LenReg = MIRBuilder.buildZExtOrTrunc(LenTy, LenReg).getReg(0);

  // We need to make sure the number of bytes is non-zero for this lowering to
  // be correct.  Since we only need to lower constant-length intrinsics for
  // now, just support those.
  if (Opc == G_MEMCPY_INLINE || !MF.getFunction().hasOptNone()) {
    if (auto ConstLen = getIConstantVRegValWithLookThrough(LenReg, MRI)) {
      // Doing something with zero bytes is a noop anyway.
      if (!ConstLen->Value) {
        MI.eraseFromParent();
        return LegalizerHelper::Legalized;
      }
      // Lowering memmove generates a lot of code...
      if (!MF.getFunction().hasOptSize() || Opc != G_MEMMOVE) {
        MachineMemOperand *StoreMMO = MI.memoperands().front();
        MachineMemOperand *LoadMMO;

        if (Opc == G_MEMSET) {
          // Store the first byte.
          MIRBuilder.buildStore(SrcReg, DstReg, *StoreMMO);

          // Use stores if 4 bytes or less
          if (ConstLen->Value.ule(4)) {
            for (unsigned int Offset = 1; ConstLen->Value.ugt(Offset);
                 ++Offset) {
              auto OffConst = MIRBuilder.buildConstant(LenTy, Offset);
              auto AddrReg = MIRBuilder.buildPtrAdd(DstTy, DstReg, OffConst);
              MIRBuilder.buildStore(
                  SrcReg, AddrReg,
                  *MF.getMachineMemOperand(StoreMMO, Offset, LLT::scalar(8)));
            }
            MI.eraseFromParent();
            return LegalizerHelper::Legalized;
          }

          // Read starting at the stored byte.
          SrcTy = DstTy;
          SrcReg = DstReg;
          LoadMMO = MF.getMachineMemOperand(
              StoreMMO->getPointerInfo(),
              (StoreMMO->getFlags() & ~MachineMemOperand::MOStore) |
                  MachineMemOperand::MOLoad,
              StoreMMO->getMemoryType(), StoreMMO->getAlign(),
              StoreMMO->getAAInfo(), StoreMMO->getRanges(),
              StoreMMO->getSyncScopeID(), StoreMMO->getSuccessOrdering(),
              StoreMMO->getFailureOrdering());
          // Write starting at the following byte.
          auto One = MIRBuilder.buildConstant(LenTy, 1);
          DstReg = MIRBuilder.buildPtrAdd(DstTy, DstReg, One).getReg(0);
          // Copy one less byte.
          LenReg = MIRBuilder.buildConstant(LenTy, --ConstLen->Value).getReg(0);
          // Now it's just an ldir.
        } else
          LoadMMO = MI.memoperands().back();

        Register DE = Is24Bit ? Z80::UDE : Z80::DE;
        Register HL = Is24Bit ? Z80::UHL : Z80::HL;
        Register BC = Is24Bit ? Z80::UBC : Z80::BC;
        auto ConstSrc = getIConstantVRegValWithLookThrough(SrcReg, MRI);
        auto ConstDst = getIConstantVRegValWithLookThrough(DstReg, MRI);
        bool ConstAddr = ConstSrc && ConstDst;
        if (!MI.hasOrderedMemoryRef() && ConstAddr &&
            ConstSrc->Value == ConstDst->Value) {
          MI.eraseFromParent();
          return LegalizerHelper::Legalized;
        }
        if (Opc == G_MEMMOVE && !ConstAddr) {
          MIRBuilder.buildCopy(HL, SrcReg);
          MIRBuilder.buildInstr(Is24Bit ? Z80::Cmp24ao : Z80::Cmp16ao, {},
                                {DstReg});
          MIRBuilder
              .buildInstr(Is24Bit ? Z80::LDR24 : Z80::LDR16, {},
                          {DstReg, SrcReg, LenReg})
              .cloneMemRefs(MI);
        } else if (Opc != G_MEMMOVE ||
                   (ConstAddr && (ConstDst->Value.ule(ConstSrc->Value) ||
                                  (ConstDst->Value - ConstSrc->Value)
                                      .uge(ConstLen->Value)))) {
          // Use loads/stores if 4 bytes or less
          if (ConstLen->Value.ule(4)) {
            for (unsigned int Offset = 0; ConstLen->Value.ugt(Offset);
                 ++Offset) {
              auto OffConst = MIRBuilder.buildConstant(LenTy, Offset);
              auto SrcAddrI = MIRBuilder.buildPtrAdd(SrcTy, SrcReg, OffConst);
              auto LoadReg = MIRBuilder.buildLoad(
                  LLT::scalar(8), SrcAddrI,
                  *MF.getMachineMemOperand(LoadMMO, Offset, LLT::scalar(8)));
              auto DstAddrI = MIRBuilder.buildPtrAdd(DstTy, DstReg, OffConst);
              MIRBuilder.buildStore(
                  LoadReg, DstAddrI,
                  *MF.getMachineMemOperand(StoreMMO, Offset, LLT::scalar(8)));
            }
          } else {
            MIRBuilder.buildCopy(DE, DstReg);
            MIRBuilder.buildCopy(HL, SrcReg);
            MIRBuilder.buildCopy(BC, LenReg);
            MIRBuilder.buildInstr(Is24Bit ? Z80::LDIR24 : Z80::LDIR16)
                .cloneMemRefs(MI);
          }
        } else {
          auto LenMinusOne =
              MIRBuilder.buildConstant(LenTy, ConstLen->Value - 1);
          MIRBuilder.buildCopy(
              DE, MIRBuilder.buildPtrAdd(DstTy, DstReg, LenMinusOne));
          MIRBuilder.buildCopy(
              HL, MIRBuilder.buildPtrAdd(SrcTy, SrcReg, LenMinusOne));
          MIRBuilder.buildCopy(BC, LenReg);
          MIRBuilder.buildInstr(Is24Bit ? Z80::LDDR24 : Z80::LDDR16)
              .cloneMemRefs(MI);
        }
        MI.eraseFromParent();
        return LegalizerHelper::Legalized;
      }
    }
  }

  MOI->setReg(LenReg);
  auto Result = createMemLibcall(MIRBuilder, MRI, MI, LocObserver);
  MI.eraseFromParent();
  return Result;
}

bool Z80LegalizerInfo::legalizeIntrinsic(LegalizerHelper &Helper,
                                         MachineInstr &MI) const {
  MachineIRBuilder &MIRBuilder = Helper.MIRBuilder;
  MachineFunction &MF = MIRBuilder.getMF();
  auto &Ctx = MF.getFunction().getContext();
  auto &CLI = *MF.getSubtarget().getCallLowering();

  switch (MI.getIntrinsicID()) {
  case Intrinsic::trap: {
    CallLowering::CallLoweringInfo Info;
    Info.CallConv = CallingConv::C;
    Info.Callee = MachineOperand::CreateES("abort");
    Info.OrigRet = CallLowering::ArgInfo{None, Type::getVoidTy(Ctx), 0};
    if (!CLI.lowerCall(MIRBuilder, Info))
      return false;
    break;
  }
  case Intrinsic::vacopy: {
    const MachineRegisterInfo &MRI = *MIRBuilder.getMRI();
    const MachineFrameInfo &MFI = MF.getFrameInfo();
    const DataLayout &DL = MF.getDataLayout();

    Register DstReg = MI.getOperand(1).getReg();
    MachineInstr *DstMI = MRI.getVRegDef(DstReg);
    MachinePointerInfo DstMPI;
    Align DstAlign = DL.getPointerABIAlignment(0);
    if (DstMI && DstMI->getOpcode() == G_FRAME_INDEX) {
      int FI = DstMI->getOperand(1).getIndex();
      DstMPI = MachinePointerInfo::getFixedStack(MF, FI);
      DstAlign = MFI.getObjectAlign(FI);
    }

    Register SrcReg = MI.getOperand(2).getReg();
    MachineInstr *SrcMI = MRI.getVRegDef(SrcReg);
    MachinePointerInfo SrcMPI;
    Align SrcAlign = DL.getPointerABIAlignment(0);
    if (SrcMI && SrcMI->getOpcode() == G_FRAME_INDEX) {
      int FI = SrcMI->getOperand(1).getIndex();
      SrcMPI = MachinePointerInfo::getFixedStack(MF, FI);
      SrcAlign = MFI.getObjectAlign(FI);
    }

    LLT p0 = LLT::pointer(0, TM.getPointerSizeInBits(0));
    MIRBuilder.buildStore(MIRBuilder.buildLoad(p0, SrcReg, SrcMPI, SrcAlign),
                          DstReg, DstMPI, DstAlign);
    break;
  }
  default:
    return false;
  }

  MI.eraseFromParent();
  return true;
}
